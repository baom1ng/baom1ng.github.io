[{"id":"8ac33153f9328c8a2ab7b8c7aad02bd2","title":"Docker搭建redis集群","content":"\n1、创建网卡[root@vm22 home]# docker network create redis --subnet 172.38.0.0&#x2F;16\n39b4f9f17a4f49a5362c1ddc11c516841e2d1fac03aae3dc484f8f22fed28e00\n2、通过脚本创建六个redis配置for port in $(seq 1 6);\ndo\nmkdir -p &#x2F;mydata&#x2F;redis&#x2F;node-$&#123;port&#125;&#x2F;conf\ntouch &#x2F;mydata&#x2F;redis&#x2F;node-$&#123;port&#125;&#x2F;conf&#x2F;redis.conf\ncat &lt;&lt; EOF &gt;&#x2F;mydata&#x2F;redis&#x2F;node-$&#123;port&#125;&#x2F;conf&#x2F;redis.conf\nport 6379\nbind 0.0.0.0\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 5000\ncluster-announce-ip 172.38.0.1$&#123;port&#125;\ncluster-announce-port 6379\ncluster-announce-bus-port 16379\nappendonly yes\nEOF\n# 启动6个容器\ndocker run -p 637$&#123;port&#125;:6379 -p 1637$&#123;port&#125; --name redis-$&#123;port&#125; \\\n-v &#x2F;mydata&#x2F;redis&#x2F;node-$&#123;port&#125;&#x2F;data:&#x2F;data \\\n-v &#x2F;mydata&#x2F;redis&#x2F;node-$&#123;port&#125;&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf \\\n-d --net redis --ip 172.38.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf\ndone\n通过命令手动启动容器\n# 这里需要执行6次（1～6）\ndocker run -p 6371:6379 -p 16371:16379 --name redis-1 \\\n-v &#x2F;mydate&#x2F;redis&#x2F;node-1&#x2F;data:&#x2F;data \\\n-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf\n启动后查看容器是否运行\n[root@vm22 home]# docker ps\nCONTAINER ID   IMAGE                    COMMAND                  CREATED          STATUS          PORTS                                              NAMES\n1a7de933e9b5   redis:5.0.9-alpine3.11   &quot;docker-entrypoint.s…&quot;   5 hours ago      Up 5 hours      0.0.0.0:6376-&gt;6379&#x2F;tcp, 0.0.0.0:49191-&gt;16376&#x2F;tcp   redis-6\naf1b568638eb   redis:5.0.9-alpine3.11   &quot;docker-entrypoint.s…&quot;   5 hours ago      Up 5 hours      0.0.0.0:6375-&gt;6379&#x2F;tcp, 0.0.0.0:49190-&gt;16375&#x2F;tcp   redis-5\n5e2d03a59e15   redis:5.0.9-alpine3.11   &quot;docker-entrypoint.s…&quot;   5 hours ago      Up 5 hours      0.0.0.0:6374-&gt;6379&#x2F;tcp, 0.0.0.0:49189-&gt;16374&#x2F;tcp   redis-4\n309de9ba38fb   redis:5.0.9-alpine3.11   &quot;docker-entrypoint.s…&quot;   5 hours ago      Up 5 hours      0.0.0.0:6373-&gt;6379&#x2F;tcp, 0.0.0.0:49188-&gt;16373&#x2F;tcp   redis-3\n977f57c106ea   redis:5.0.9-alpine3.11   &quot;docker-entrypoint.s…&quot;   5 hours ago      Up 5 hours      0.0.0.0:6372-&gt;6379&#x2F;tcp, 0.0.0.0:49187-&gt;16372&#x2F;tcp   redis-2\n375ef095a557   redis:5.0.9-alpine3.11   &quot;docker-entrypoint.s…&quot;   5 hours ago      Up 5 hours      0.0.0.0:6371-&gt;6379&#x2F;tcp, 0.0.0.0:49192-&gt;16371&#x2F;tcp   redis-1\n3、创建集群# 进入 redis-1\n[root@vm22 home]# docker exec -it redis-1 &#x2F;bin&#x2F;sh\n# redis镜像是精简版系统没有bash\n# 创建集群\n&#x2F;data # redis-cil --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.1\n5:6379 172.38.0.16:6379 --cluster-repliceas 1\n# 查看集群是否创建成功\n&#x2F;data # redis-cli -c\n127.0.0.1:6379&gt; cluster nodes\n7eb510a2027c3b7d20b0a45517ab78019f53a77b 172.38.0.16:6379@16379 slave 7e2fa24a6b549cbadddfa8b281ae5ae457d7c4de 0 1664709975579 6 connected\n428e53fa38bcb638fb7e29278d36319d5c72333c 172.38.0.15:6379@16379 slave 40c0b3ea11e43ef9806f202824797c28f7222616 0 1664709975882 5 connected\n7e2fa24a6b549cbadddfa8b281ae5ae457d7c4de 172.38.0.12:6379@16379 master - 0 1664709975000 2 connected 5461-10922\n40c0b3ea11e43ef9806f202824797c28f7222616 172.38.0.11:6379@16379 myself,master - 0 1664709975000 1 connected 0-5460\nbc3a93e0655a4c635ffe08cc5a0ca2c854df60c2 172.38.0.14:6379@16379 slave d939b0a965bb54be4cb05be5f18a6cd43f910e62 0 1664709974000 4 connected\nd939b0a965bb54be4cb05be5f18a6cd43f910e62 172.38.0.13:6379@16379 master - 0 1664709974000 3 connected 10923-16383\n127.0.0.1:6379&gt; cluster info\ncluster_state:ok\ncluster_slots_assigned:16384\ncluster_slots_ok:16384\ncluster_slots_pfail:0\ncluster_slots_fail:0\ncluster_known_nodes:6\ncluster_size:3\ncluster_current_epoch:6\ncluster_my_epoch:1\ncluster_stats_messages_ping_sent:35066\ncluster_stats_messages_pong_sent:35812\ncluster_stats_messages_sent:70878\ncluster_stats_messages_ping_received:35807\ncluster_stats_messages_pong_received:35066\ncluster_stats_messages_meet_received:5\ncluster_stats_messages_received:70878","slug":"Docker-redis集群","date":"2022-10-02T02:34:20.000Z","categories_index":"Docker","tags_index":"Docker","author_index":"Johnny"},{"id":"75603112ad785d198fb30f0b34b1d632","title":"Dockerfile","content":"Dockerfile1. 什么是DockerfileDockerfile可以认为是Docker镜像的描述文件，是由一系列命令和参数构成的脚本。主要作用是用来构建docker镜像的构建文件。\n\n\n通过架构图可以看出通过DockerFile可以直接构建镜像\n\n2. Dockerfile解析过程\n3 .Dockerfile的保留命令官方说明:https://docs.docker.com/engine/reference/builder/\n\n\n\n保留字\n作用\n\n\n\nFROM\n当前镜像是基于哪个镜像的 第一个指令必须是FROM\n\n\nMAINTAINER\n镜像维护者的姓名和邮箱地址\n\n\nRUN\n构建镜像时需要运行的指令\n\n\nEXPOSE\n当前容器对外暴露出的端口号\n\n\nWORKDIR\n指定在创建容器后，终端默认登录进来的工作目录，一个落脚点\n\n\nENV\n用来在构建镜像过程中设置环境变量\n\n\nADD\n将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包\n\n\nCOPY\n类似于ADD，拷贝文件和目录到镜像中将从构建上下文目录中&lt;原路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置\n\n\nVOLUME\n容器数据卷，用于数据保存和持久化工作\n\n\nCMD\n指定一个容器启动时要运行的命令Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换\n\n\nENTRYPOINT\n指定一个容器启动时要运行的命令ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数\n\n\n3.1 FROM 命令\n基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现\n\n语法:\n  FROM  &lt;image&gt;\nFROM  &lt;image&gt;[:&lt;tag&gt;]     使用版本不写为latest\nFROM  &lt;image&gt;[@&lt;digest&gt;]  使用摘要\n\n3.2 MAINTAINER  命令\n镜像维护者的姓名和邮箱地址[废弃]\n\n语法:\n  MAINTAINER &lt;name&gt;\n\n3.3 RUN 命令\nRUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步\n\n语法:\n  RUN &lt;command&gt; (shell form, the command is run in a shell, which by default is &#x2F;bin&#x2F;sh -c on Linux or cmd &#x2F;S &#x2F;C on Windows)\nRUN echo hello\n\nRUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (exec form)\nRUN [&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]\n\n3.4 EXPOSE 命令\n用来指定构建的镜像在运行为容器时对外暴露的端口\n\n语法:\n  EXPOSE 80&#x2F;tcp  如果没有显示指定则默认暴露都是tcp\nEXPOSE 80&#x2F;udp\n\n3.5 CMD 命令\n用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。\n\n注意: Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。\n\n语法:\n  CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec form, this is the preferred form)\nCMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT)\nCMD command param1 param2 (shell form)\n\n3.6 WORKDIR 命令\n用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。\n\n语法:\n  WORKDIR &#x2F;path&#x2F;to&#x2F;workdir\n\nWORKDIR &#x2F;a\nWORKDIR b\nWORKDIR c\n&#96;注意:WORKDIR指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对&#96;\n\n3.7 ENV 命令\n用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。\n\n语法：\n  ENV &lt;key&gt; &lt;value&gt;\nENV &lt;key&gt;&#x3D;&lt;value&gt; ...\n\n3.8 ADD 命令\n用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。\n\n语法:\n  ADD hom* &#x2F;mydir&#x2F;       通配符添加多个文件\nADD hom?.txt &#x2F;mydir&#x2F;   通配符添加\nADD test.txt relativeDir&#x2F;  可以指定相对路径\nADD test.txt &#x2F;absoluteDir&#x2F; 也可以指定绝对路径\nADD url \n\n3.9 COPY 命令\n用来将context目录中指定文件复制到镜像的指定目录中\n\n语法:\n  COPY src dest\nCOPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]\n\n3.10 VOLUME 命令\n用来定义容器运行时可以挂在到宿主机的目录\n\n语法:\n  VOLUME [&quot;&#x2F;data&quot;]\n\n3.11 ENTRYPOINT命令\n用来指定容器启动时执行命令和CMD类似\n\n语法:\n  [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]\nENTRYPOINT command param1 param2\n\n  ENTRYPOINT指令，往往用于设置容器启动后的第一个命令，这对一个容器来说往往是固定的。  CMD指令，往往用于设置容器启动的第一个命令的默认参数，这对一个容器来说可以是变化的。\n\n\nDockerfile构建HEXO项目部署4.1编写DockerfileFROM centos:7\nRUN [&quot;yum&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;git&quot;,&quot;vim&quot;]\nWORKDIR &#x2F;home&#x2F;hexo\nEXPOSE 4000\n#安装nodejs\nADD https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v16.13.2&#x2F;node-v16.13.2-linux-x64.tar.xz &#x2F;home\nRUN mkdir -p &#x2F;usr&#x2F;local&#x2F;lib&#x2F;nodejs\nRUN tar -xJvf &#x2F;home&#x2F;node*.tar.xz\nRUN mv node-*-linux-x64 &#x2F;usr&#x2F;local&#x2F;nodejs \nENV PATH&#x3D;$PATH:&#39;&#x2F;usr&#x2F;local&#x2F;nodejs&#x2F;bin&#39;\n#安装hexo\nRUN npm install hexo-cli -g\nENV PATH&#x3D;&quot;$PATH:.&#x2F;node_modules&#x2F;.bin&quot;\nRUN hexo init\nCMD hexo server\n\n4.2构建镜像[root@localhost ems]# docker build -t hexo1.0 .\n\n4.3运行镜像[root@localhost ems]# docker run -d -p 8080:4000 --name hexo hexo1.0\n\n4.4访问项目http:&#x2F;&#x2F;127.0.0.1:4000\n\n\n\n\n","slug":"Dockerflie","date":"2022-10-01T06:21:20.000Z","categories_index":"Docker","tags_index":"Docker","author_index":"Johnny"},{"id":"2e8be22ca0c67568a1ab56634abc99c8","title":"Docker网络详解","content":"\n理解Docker0ip addr #查看本机网络网卡有三个网络问题：Docker是如何处理容器网络访问的？\n[root@vm22 ~]# docker run -d -P --name tomcat01 tomcat\n#查看容器内部网络地址 ip addr 或者 dcoker inspect\n[root@vm22 ~]# docker inspect tomcat01\n&quot;Networks&quot;: &#123;\n                &quot;bridge&quot;: &#123;\n                    &quot;IPAMConfig&quot;: null,\n                    &quot;Links&quot;: null,\n                    &quot;Aliases&quot;: null,\n                    &quot;NetworkID&quot;: &quot;2893fe225a852d859fb8e831ff668623b9f220c3f47a8b1b83bb31691a8961b5&quot;,\n                    &quot;EndpointID&quot;: &quot;a6dca6dc3b938d365f9e0cffdc0944e0ce94dd980c5cde5826dfaf6ce3323ea5&quot;,\n                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;,\n                    &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,  # Docker分配的ip地址\n                    &quot;IPPrefixLen&quot;: 16,\n                    &quot;IPv6Gateway&quot;: &quot;&quot;,\n                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,\n                    &quot;GlobalIPv6PrefixLen&quot;: 0,\n                    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,\n                    &quot;DriverOpts&quot;: null\n                &#125;\n            &#125;\n# 可以看到我在Linux上可以ping通容器\n[root@vm22 ~]# ping 172.17.0.2\nPING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.\n64 bytes from 172.17.0.2: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.729 ms\n64 bytes from 172.17.0.2: icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.111 ms\n64 bytes from 172.17.0.2: icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.135 ms\n原理：\n我们每启动一个docker容器，docker就会给容器分配一个IP地址，我们只要安装了docker，就会有一个网卡docker0。\n\n\nDocker 桥接模式，使用了evth-pair技术！\n\n\n我们每启动一个容器，我们的主机就就会多一对网卡2. 我们发现容器的网卡都是成对的\n\nevth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一端连接协议，一端相互连接\n正因为有这个特性，evth-pair 充当一个桥梁，连接各种虚拟网络设备\nOpenstac，Docker容器之间的连接，OVS的连接，都使用 ecth-pair 技术\n\n\n容器之间是可以互相通讯的root@7f57cd426938:&#x2F;usr&#x2F;local&#x2F;tomcat# ping 172.17.0.3\nPING 172.17.0.3 (172.17.0.3) 56(84) bytes of data.\n64 bytes from 172.17.0.3: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.104 ms\n64 bytes from 172.17.0.3: icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.113 ms\n结论：tomcat01和tomcat02公用一个路由docker0\n\n\n\n\n\n\n\n\n小结Docker使用的Linux的桥接网络，宿主机中是一个Docker容器的网桥 Docker0\n\n\n\nDocker中的所有网络接口都是虚拟的。\n只要删除容器，对应的网桥就被删除。–link\n\n\n\n\n\n\n\n\n\n\n在我们搭建服务中，database url=IP，项目不重启，但是数据库ip换掉了，针对这种情况我们可以使用容器的名称来访问容器。\n# 我们直接通过容器的名称去ping发现ping不通\n[root@vm22 ~]# docker exec -it tomcat01 ping tomcat02\nping: tomcat02: No address associated with hostname\n\n# 在启动容器时使用--link命令将tomcat02和tomcat03进行连接\n[root@vm22 ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat:full\n75659bb40133489c9c6e14bd33bc30325cd1449fadec648f7e8fdf8a0b0e2a32\n\n# 使用--link命令后我们发现tomcat03可以直接通过容器名称连接tomcat02\n[root@vm22 ~]# docker exec -it tomcat03 ping tomcat02\nPING tomcat02 (172.17.0.3) 56(84) bytes of data.\n64 bytes from tomcat02 (172.17.0.3): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.176 ms\n64 bytes from tomcat02 (172.17.0.3): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.074 ms\n\n#但是我们反向无法ping通\n[root@vm22 ~]# docker exec -it tomcat02 ping tomcat03\nping: tomcat03: No address associated with hostname\n我们可以看到在tomcat03中配置了tomcat02的地址\n[root@vm22 ~]# docker exec -it tomcat03 cat &#x2F;etc&#x2F;hosts\n127.0.0.1       localhost\n::1     localhost ip6-localhost ip6-loopback\nfe00::0 ip6-localnet\nff00::0 ip6-mcastprefix\nff02::1 ip6-allnodes\nff02::2 ip6-allrouters\n172.17.0.3      tomcat02 0f01224e35e7\n172.17.0.4      75659bb40133\n–link 就是我们在hosts中增加了一个tomcat02的映射我们实际使用中不建议使用 –link，我们使用自定义网络来实现容器之前的互联\n自定义网络\n\n\n\n\n\n\n\n\n\n查看所有的Docker网络\n[root@vm22 ~]# docker network ls\nNETWORK ID     NAME      DRIVER    SCOPE\n2893fe225a85   bridge    bridge    local\n9612893a759b   host      host      local\nd67b91c2d6f8   none      null      local\n网络模式bridge：桥接 docker（默认），自定义网络使用bridgenone：不配置网络host：和宿主机共享网络container：容器之间网络连通创建一个自定义网络\n# 自定义一个名为mynet的网络\n#  --driver bridge\n#  --subnet 192.168.0.0&#x2F;24\n#  --gateway 192.168.0.1\n[root@vm22 ~]# docker network create --driver bridge --subnet 192.168.0.0&#x2F;24 --gateway 192.168.0.1 mynet\nbe625b138967ed399a64b6a96fbaade1e702ed6c7c07f66b59528e8077e44339\n\n[root@vm22 ~]# docker network ls\nNETWORK ID     NAME      DRIVER    SCOPE\n2893fe225a85   bridge    bridge    local\n9612893a759b   host      host      local\nbe625b138967   mynet     bridge    local\nd67b91c2d6f8   none      null      local\n\n# 测试容器之间的连接\n[root@vm22 ~]# docker exec -it tomcat1 ping tomcat2\nPING tomcat2 (192.168.0.3) 56(84) bytes of data.\n64 bytes from tomcat2.mynet (192.168.0.3): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.626 ms\n64 bytes from tomcat2.mynet (192.168.0.3): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.218 ms\n网络连通#在docker0上创建tomcat3\n[root@vm22 ~]# docker run -d -P --name tomcat3 tomcat:full\n5c7b8afd60f532a0a50fe570ffcad8a5a40cd0ab946ddc51449140a0dbbd776f\n#测试tomcat3是否能与tomcat1连通\n[root@vm22 ~]# docker exec -it tomcat3 ping tomcat1\nping: tomcat1: No address associated with hostname\n#使用命令 docker network connect 连接两个网络\n[root@vm22 ~]# docker network connect mynet tomcat3\n[root@vm22 ~]# docker exec -it tomcat3 ping tomcat1\nPING tomcat1 (192.168.0.3) 56(84) bytes of data.\n64 bytes from tomcat1.mynet (192.168.0.3): icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.063 ms\n64 bytes from tomcat1.mynet (192.168.0.3): icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.263 ms\n如果需要容器间相互连接，就需要使用docker network connect连接！\n","slug":"Docker网络详解","date":"2021-10-29T02:23:20.000Z","categories_index":"Docker","tags_index":"Docker","author_index":"Johnny"},{"id":"6ec80148ccdf0bae5b573fc594b500be","title":"Docker的基础命令","content":"\n帮助命令\ndocker version             #显示docker的版本信息\ndocker info                #显示dcoker的系统信息，包括镜像和容器的数量\ndocker [命令] --help        #帮助命令\ndocker官方文档地址：https://docs.docker.com/compose/reference/\n镜像命令\ndocker images 查看所有本地主机上的镜像\n[root@vm22 ~]# docker images\nREPOSITORY            TAG       IMAGE ID       CREATED         SIZE\nwaibi&#x2F;centos          1.0       161ad1397191   7 hours ago     231MB\ntomcat                2.0       8663b1d60f71   8 hours ago     684MB\nnginx                 latest    605c77e624dd   9 months ago    141MB\n#解释\nREPOSITORY    镜像的仓库源\nTAG           镜像的标签\nIMAGE ID      镜像的ID\nCREATED       镜像的创建时间\nSIZE          镜像的大小\n#可选项\n-a --all      显示所有镜像\n-q --quiet    只显示景象ID\ndocker search 搜索镜像\n[root@vm22 ~]# docker search mysql\nNAME                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED\nmysql                           MySQL is a widely used, open-source relation…   13234     [OK]       \nmariadb                         MariaDB Server is a high performing open sou…   5062      [OK]       \n#可选项\n--filter&#x3D;starts&#x3D;3000    #搜索出来镜像starts大于3000的镜像\ndocker pull 下载镜像\n下载镜像 $ docker pull 镜像名[:tag]\n[root@vm22 ~]# docker pull mysql\nUsing default tag: latest  #如果指定tag，将默认下载latest\nlatest: Pulling from library&#x2F;mysql\n72a69066d2fe: Already exists  #分层下载\n93619dbc5b36: Already exists \n99da31dd6142: Already exists \n626033c43d70: Already exists \n37d5d7efb64e: Already exists \nac563158d721: Already exists \nd2ba16033dad: Already exists \n688ba7d5c01a: Pull complete \n00e060b6d11d: Pull complete \n1c04857f594f: Pull complete \n4d7cfa90e6ea: Pull complete \ne0431212d27d: Pull complete \nDigest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709 #签名\nStatus: Downloaded newer image for mysql:latest\ndocker.io&#x2F;library&#x2F;mysql:latest #真实地址\ndocker rmi 删除镜像\n[root@vm22 ~]# docker rmi -f 3218b38490ce #删除指定镜像\n[root@vm22 ~]# docker rmi -f IMAGE ID IMAGE ID #删除多个镜像\n[root@vm22 ~]# docker rmi -f $(docker images -aq) #删除全部镜像\n容器命令\n启动容器\n$ docker run IMAGE [COMMAND] [ARG...]\n# 参数说明\n--name&#x3D;&quot;name&quot;  给容器命名\n-d  后台运行\n-it  使用交互方式运行，进入容器查看内容\n-p  指定容器端口 -p 8080:8080\n        -p 主机端口:容器端口\n        -p IP:主机端口:容器端口\n-P  随机指定端口\n\n#启动并进入容器\n[root@vm22 ~]# docker run -it centos &#x2F;bin&#x2F;bash\n[root@bdcf79e05d39 &#x2F;]# ls  # 查看容器内的centos\nbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\n[root@bdcf79e05d39 &#x2F;]# exit  # 退出容器 \nexit\n列出所有正在运行的容器\n# docker ps 命令\n-a # 列出当前正在运行的容器+历史运行过的容器\n-n&#x3D;?  # 显示最近创建的容器\n-q  # 只显示容器ID\n[root@vm22 ~]# docker ps\nCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES\n[root@vm22 ~]# docker ps -a\nCONTAINER ID   IMAGE     COMMAND       CREATED         STATUS                          PORTS     NAMES\nbdcf79e05d39   centos    &quot;&#x2F;bin&#x2F;bash&quot;   3 minutes ago   Exited (0) About a minute ago             brave_jepsen\n退出容器\nexit  # 直接停止并退出容器\nCtrl + P + Q  # 容器不停止退出\n删除容器\ndocker rm 容器id  #删除指定容器\ndocker rm -f $(docker ps -aq)  # 删除所有容器\n启动和停止容器操作\ndocker start 容器ID    # 启动容器\ndocker stop 容器ID    # 停止当前正在运行的容器\ndocker restart 容器ID    # 重启容器\ndocker kill 容器ID    # 强制停止容器\n其他常用命令\n后台启动容器\n# 命令 doceker run -d 镜像\n[root@vm22 ~]# docker run -d centos\n查看日志\ndocker logs -f -t --tail 容器\n# 测试\n[root@vm22 ~]# docker run -d centos &#x2F;bin&#x2F;bash -c &quot;while true;do echo print logs;sleep 1;done &quot;\n[root@vm22 ~]# docker ps\nCONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES\n82bb167358c7   centos    &quot;&#x2F;bin&#x2F;bash -c &#39;while…&quot;   34 seconds ago   Up 33 seconds             hungry_mclean\n# 显示日志\n  -tf \n  --tail number\n[root@vm22 ~]# docker logs -t -f --tail 4 82bb167358c7\n2022-09-28T17:41:05.146127148Z print logs\n2022-09-28T17:41:06.151409147Z print logs\n2022-09-28T17:41:07.157108266Z print logs\n2022-09-28T17:41:08.161395599Z print logs\n查看容器中进程信息\n# 命令 docker top 容器ID\n[root@vm22 ~]# docker top 82bb167358c7\nUID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD\nroot                4773                4753                0                   01:39               ?                   00:00:00            &#x2F;bin&#x2F;bash -c while true;do echo print logs;sleep 1;done\nroot                5172                4773                0                   01:44               ?                   00:00:00            &#x2F;usr&#x2F;bin&#x2F;coreutils --coreutils-prog-shebang&#x3D;sleep &#x2F;usr&#x2F;bin&#x2F;sleep 1\n 查看镜像的元数据\n# 命令 docker inspect 容器ID\n[root@vm22 ~]# docker inspect 82bb167358c7\n[\n    &#123;\n        &quot;Id&quot;: &quot;82bb167358c7835cae235ad9d3ba2097e5d63ecd7286de50fb26061467d9ef4b&quot;,\n        &quot;Created&quot;: &quot;2022-09-28T17:39:20.314052558Z&quot;,\n        &quot;Path&quot;: &quot;&#x2F;bin&#x2F;bash&quot;,\n        &quot;Args&quot;: [\n            &quot;-c&quot;,\n            &quot;while true;do echo print logs;sleep 1;done &quot;\n        ],\n        &quot;State&quot;: &#123;\n            &quot;Status&quot;: &quot;running&quot;,\n            &quot;Running&quot;: true,\n            &quot;Paused&quot;: false,\n            &quot;Restarting&quot;: false,\n            &quot;OOMKilled&quot;: false,\n            &quot;Dead&quot;: false,\n            &quot;Pid&quot;: 4773,\n            &quot;ExitCode&quot;: 0,\n            &quot;Error&quot;: &quot;&quot;,\n            &quot;StartedAt&quot;: &quot;2022-09-28T17:39:20.57549319Z&quot;,\n            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;\n        &#125;,\n        &quot;Image&quot;: &quot;sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6&quot;,\n        &quot;ResolvConfPath&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;82bb167358c7835cae235ad9d3ba2097e5d63ecd7286de50fb26061467d9ef4b&#x2F;resolv.conf&quot;,\n        &quot;HostnamePath&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;82bb167358c7835cae235ad9d3ba2097e5d63ecd7286de50fb26061467d9ef4b&#x2F;hostname&quot;,\n        &quot;HostsPath&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;82bb167358c7835cae235ad9d3ba2097e5d63ecd7286de50fb26061467d9ef4b&#x2F;hosts&quot;,\n        &quot;LogPath&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;82bb167358c7835cae235ad9d3ba2097e5d63ecd7286de50fb26061467d9ef4b&#x2F;82bb167358c7835cae235ad9d3ba2097e5d63ecd7286de50fb26061467d9ef4b-json.log&quot;,\n        &quot;Name&quot;: &quot;&#x2F;hungry_mclean&quot;,\n        &quot;RestartCount&quot;: 0,\n        &quot;Driver&quot;: &quot;overlay2&quot;,\n        &quot;Platform&quot;: &quot;linux&quot;,\n        &quot;MountLabel&quot;: &quot;&quot;,\n        &quot;ProcessLabel&quot;: &quot;&quot;,\n        &quot;AppArmorProfile&quot;: &quot;&quot;,\n        &quot;ExecIDs&quot;: null,\n        &quot;HostConfig&quot;: &#123;\n            &quot;Binds&quot;: null,\n            &quot;ContainerIDFile&quot;: &quot;&quot;,\n            &quot;LogConfig&quot;: &#123;\n                &quot;Type&quot;: &quot;json-file&quot;,\n                &quot;Config&quot;: &#123;&#125;\n            &#125;,\n            &quot;NetworkMode&quot;: &quot;default&quot;,\n            &quot;PortBindings&quot;: &#123;&#125;,\n            &quot;RestartPolicy&quot;: &#123;\n                &quot;Name&quot;: &quot;no&quot;,\n                &quot;MaximumRetryCount&quot;: 0\n            &#125;,\n            &quot;AutoRemove&quot;: false,\n            &quot;VolumeDriver&quot;: &quot;&quot;,\n            &quot;VolumesFrom&quot;: null,\n            &quot;CapAdd&quot;: null,\n            &quot;CapDrop&quot;: null,\n            &quot;CgroupnsMode&quot;: &quot;host&quot;,\n            &quot;Dns&quot;: [],\n            &quot;DnsOptions&quot;: [],\n            &quot;DnsSearch&quot;: [],\n            &quot;ExtraHosts&quot;: null,\n            &quot;GroupAdd&quot;: null,\n            &quot;IpcMode&quot;: &quot;private&quot;,\n            &quot;Cgroup&quot;: &quot;&quot;,\n            &quot;Links&quot;: null,\n            &quot;OomScoreAdj&quot;: 0,\n            &quot;PidMode&quot;: &quot;&quot;,\n            &quot;Privileged&quot;: false,\n            &quot;PublishAllPorts&quot;: false,\n            &quot;ReadonlyRootfs&quot;: false,\n            &quot;SecurityOpt&quot;: null,\n            &quot;UTSMode&quot;: &quot;&quot;,\n            &quot;UsernsMode&quot;: &quot;&quot;,\n            &quot;ShmSize&quot;: 67108864,\n            &quot;Runtime&quot;: &quot;runc&quot;,\n            &quot;ConsoleSize&quot;: [\n                0,\n                0\n            ],\n            &quot;Isolation&quot;: &quot;&quot;,\n            &quot;CpuShares&quot;: 0,\n            &quot;Memory&quot;: 0,\n            &quot;NanoCpus&quot;: 0,\n            &quot;CgroupParent&quot;: &quot;&quot;,\n            &quot;BlkioWeight&quot;: 0,\n            &quot;BlkioWeightDevice&quot;: [],\n            &quot;BlkioDeviceReadBps&quot;: null,\n            &quot;BlkioDeviceWriteBps&quot;: null,\n            &quot;BlkioDeviceReadIOps&quot;: null,\n            &quot;BlkioDeviceWriteIOps&quot;: null,\n            &quot;CpuPeriod&quot;: 0,\n            &quot;CpuQuota&quot;: 0,\n            &quot;CpuRealtimePeriod&quot;: 0,\n            &quot;CpuRealtimeRuntime&quot;: 0,\n            &quot;CpusetCpus&quot;: &quot;&quot;,\n            &quot;CpusetMems&quot;: &quot;&quot;,\n            &quot;Devices&quot;: [],\n            &quot;DeviceCgroupRules&quot;: null,\n            &quot;DeviceRequests&quot;: null,\n            &quot;KernelMemory&quot;: 0,\n            &quot;KernelMemoryTCP&quot;: 0,\n            &quot;MemoryReservation&quot;: 0,\n            &quot;MemorySwap&quot;: 0,\n            &quot;MemorySwappiness&quot;: null,\n            &quot;OomKillDisable&quot;: false,\n            &quot;PidsLimit&quot;: null,\n            &quot;Ulimits&quot;: null,\n            &quot;CpuCount&quot;: 0,\n            &quot;CpuPercent&quot;: 0,\n            &quot;IOMaximumIOps&quot;: 0,\n            &quot;IOMaximumBandwidth&quot;: 0,\n            &quot;MaskedPaths&quot;: [\n                &quot;&#x2F;proc&#x2F;asound&quot;,\n                &quot;&#x2F;proc&#x2F;acpi&quot;,\n                &quot;&#x2F;proc&#x2F;kcore&quot;,\n                &quot;&#x2F;proc&#x2F;keys&quot;,\n                &quot;&#x2F;proc&#x2F;latency_stats&quot;,\n                &quot;&#x2F;proc&#x2F;timer_list&quot;,\n                &quot;&#x2F;proc&#x2F;timer_stats&quot;,\n                &quot;&#x2F;proc&#x2F;sched_debug&quot;,\n                &quot;&#x2F;proc&#x2F;scsi&quot;,\n                &quot;&#x2F;sys&#x2F;firmware&quot;\n            ],\n            &quot;ReadonlyPaths&quot;: [\n                &quot;&#x2F;proc&#x2F;bus&quot;,\n                &quot;&#x2F;proc&#x2F;fs&quot;,\n                &quot;&#x2F;proc&#x2F;irq&quot;,\n                &quot;&#x2F;proc&#x2F;sys&quot;,\n                &quot;&#x2F;proc&#x2F;sysrq-trigger&quot;\n            ]\n        &#125;,\n        &quot;GraphDriver&quot;: &#123;\n            &quot;Data&quot;: &#123;\n                &quot;LowerDir&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;fcd02afc26d5c1aea385a6b77399b4ec4af0f356359e91041cde84cb9b1237c7-init&#x2F;diff:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;d95e550d4f62886c70a537524378ebfba5e96932146481454237df6005a0cb8c&#x2F;diff&quot;,\n                &quot;MergedDir&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;fcd02afc26d5c1aea385a6b77399b4ec4af0f356359e91041cde84cb9b1237c7&#x2F;merged&quot;,\n                &quot;UpperDir&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;fcd02afc26d5c1aea385a6b77399b4ec4af0f356359e91041cde84cb9b1237c7&#x2F;diff&quot;,\n                &quot;WorkDir&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;fcd02afc26d5c1aea385a6b77399b4ec4af0f356359e91041cde84cb9b1237c7&#x2F;work&quot;\n            &#125;,\n            &quot;Name&quot;: &quot;overlay2&quot;\n        &#125;,\n        &quot;Mounts&quot;: [],\n        &quot;Config&quot;: &#123;\n            &quot;Hostname&quot;: &quot;82bb167358c7&quot;,\n            &quot;Domainname&quot;: &quot;&quot;,\n            &quot;User&quot;: &quot;&quot;,\n            &quot;AttachStdin&quot;: false,\n            &quot;AttachStdout&quot;: false,\n            &quot;AttachStderr&quot;: false,\n            &quot;Tty&quot;: false,\n            &quot;OpenStdin&quot;: false,\n            &quot;StdinOnce&quot;: false,\n            &quot;Env&quot;: [\n                &quot;PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin&quot;\n            ],\n            &quot;Cmd&quot;: [\n                &quot;&#x2F;bin&#x2F;bash&quot;,\n                &quot;-c&quot;,\n                &quot;while true;do echo print logs;sleep 1;done &quot;\n            ],\n            &quot;Image&quot;: &quot;centos&quot;,\n            &quot;Volumes&quot;: null,\n            &quot;WorkingDir&quot;: &quot;&quot;,\n            &quot;Entrypoint&quot;: null,\n            &quot;OnBuild&quot;: null,\n            &quot;Labels&quot;: &#123;\n                &quot;org.label-schema.build-date&quot;: &quot;20210915&quot;,\n                &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,\n                &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;,\n                &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,\n                &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;\n            &#125;\n        &#125;,\n        &quot;NetworkSettings&quot;: &#123;\n            &quot;Bridge&quot;: &quot;&quot;,\n            &quot;SandboxID&quot;: &quot;0cd61c994ce552f0c40d92076a80223aa1ca509814ced1ba2e05ca3006f800a1&quot;,\n            &quot;HairpinMode&quot;: false,\n            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,\n            &quot;LinkLocalIPv6PrefixLen&quot;: 0,\n            &quot;Ports&quot;: &#123;&#125;,\n            &quot;SandboxKey&quot;: &quot;&#x2F;var&#x2F;run&#x2F;docker&#x2F;netns&#x2F;0cd61c994ce5&quot;,\n            &quot;SecondaryIPAddresses&quot;: null,\n            &quot;SecondaryIPv6Addresses&quot;: null,\n            &quot;EndpointID&quot;: &quot;4791507c4b3d9221dcca506844705803e4d6faafeacfa206225650490224ba02&quot;,\n            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,\n            &quot;GlobalIPv6Address&quot;: &quot;&quot;,\n            &quot;GlobalIPv6PrefixLen&quot;: 0,\n            &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,\n            &quot;IPPrefixLen&quot;: 16,\n            &quot;IPv6Gateway&quot;: &quot;&quot;,\n            &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,\n            &quot;Networks&quot;: &#123;\n                &quot;bridge&quot;: &#123;\n                    &quot;IPAMConfig&quot;: null,\n                    &quot;Links&quot;: null,\n                    &quot;Aliases&quot;: null,\n                    &quot;NetworkID&quot;: &quot;2893fe225a852d859fb8e831ff668623b9f220c3f47a8b1b83bb31691a8961b5&quot;,\n                    &quot;EndpointID&quot;: &quot;4791507c4b3d9221dcca506844705803e4d6faafeacfa206225650490224ba02&quot;,\n                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;,\n                    &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,\n                    &quot;IPPrefixLen&quot;: 16,\n                    &quot;IPv6Gateway&quot;: &quot;&quot;,\n                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,\n                    &quot;GlobalIPv6PrefixLen&quot;: 0,\n                    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,\n                    &quot;DriverOpts&quot;: null\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n]\n进入当前正在运行的容器\n# 命令\ndocker exec -it 容器ID &#x2F;bin&#x2F;bahs  # 进入容器后开启一个新的终端\ndocker attch 容器ID # 进入容器正在执行的终端，不会启动新的进程\n从容器内拷贝文件到主机上\ndocker cp 容器ID:容器内路径 目标路径\n[root@vm22 ~]# docker cp cfb377b1b56f:&#x2F;home&#x2F;docker-cp &#x2F;home\n[root@vm22 ~]# ls &#x2F;home\ndocker-cp  docker-test-volume  mysql  test","slug":"Docker的基础命令","date":"2021-10-07T07:03:20.000Z","categories_index":"Docker","tags_index":"Docker","author_index":"Johnny"},{"id":"a4200f3b83fd12fc52df8fa786ffcf93","title":"Nginx负载均衡","content":"\n上篇文章讲了nginx的常见模块，这边文章将为大家讲一下nginx的负载均衡。\n1.准备工作这里我用三台服务器来做演示：\n\nNginx负载均衡:192.168.10.22:80\nNginx Web1:192.168.10.23:80\nNginx Web2:192.168.10.24:80为了方便演示我这里用默认的80端口\n\n为了验证效果我们写一个简单html主页：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;title&gt;这是服务器1&lt;&#x2F;title&gt; \n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    &lt;center&gt;\n        &lt;h1&gt;这是服务器1&lt;&#x2F;h1&gt;\n    &lt;&#x2F;center&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n将以上代码复制两份命名为index.html ，注意将第二份&lt;title&gt;这是服务器1&lt;/title&gt; 改成2。##2.配置Web服务器首先将index.html文件上传到两台服务器上服务器上\n$ mkdir &#x2F;data\n$ mkdir &#x2F;data&#x2F;www\n# 创建web目录\n创建nginx配置文件/etc/nginx/conf.d/web.confNginx的安装请参考上一篇文章\n$ vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;web.conf\n# 复制下面配置文件\nserver  &#123;\n        listen  80;\n        server_name     localhost; \n        location &#x2F; &#123;\n        root &#x2F;data&#x2F;www;  # index.html文件的目录\n        index   index.html;\n        &#125;\n        error_page 404  &#x2F;404.html;\n        error_page 500 502 503 504 &#x2F;50x.html;\n        location &#x3D; &#x2F;50x.html &#123;\n        root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;\n        &#125;\n&#125;\n# 检查配置文件\n$ nginx -t\nnginx: the configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf syntax is ok\nnginx: configuration file &#x2F;etc&#x2F;nginx&#x2F;nginx.conf test is successful\n# 重新加载nginx配置\n$ nginx -s reload\n打开浏览器输入&lt;ip地址&gt;可以看到以下页面，说明web服务器配置成功。第二台web配置和第一台一样##3.配置nginx负载均衡首先我们创建配置文件/etc/nginx/conf.d/1.conf\n$ vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;1.conf\n# 写入下面的配置文件\nserver  &#123;\n        listen  80;\n        server_name     localhost;\n        location &#x2F; &#123;\n        proxy_pass http:&#x2F;&#x2F;www;\n        # 这里的www是自己设置的负载均衡池的名称\n        &#125;\n        error_page 404  &#x2F;404.html;\n        error_page 500 502 503 504 &#x2F;50x.html;\n        location &#x3D; &#x2F;50x.html &#123;\n        root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;\n        &#125;\n&#125;\n# 负载均衡池，这里我用的轮询模式\nupstream  www &#123;\n     server    192.168.10.23;\n     server    192.168.10.24;\n&#125;\n# 检查nginx配置文件\n$ nignx -t\n$ nginx -s reload\n在浏览器里输入&lt;192.168.10.22&gt;我们可以看到页面正常显示。我们再次刷新一下页面：可以看到访问顺序是：服务器1&gt;服务器2&gt;服务器1&gt;服务器2，说明负载均衡配置成功。\n##3.Nginx负载均衡模式1.轮询轮询方式是Nginx负载默认的方式，顾名思义，所有请求都按照时间顺序分配到不同的服务上，如果服务Down掉，可以自动剔除，如下配置后轮训10.23服务和10.24服务。\nupstream  www &#123;\n     server    192.168.10.23;\n     server    192.168.10.24;\n&#125;\n2.权重指定每个服务的权重比例，weight和访问比率成正比，通常用于后端服务机器性能不统一，将性能好的分配权重高来发挥服务器最大性能，如下配置后10.23服务的访问比率会是10.24服务的二倍。\nupstream  dalaoyang-server &#123;\n     server    192.168.10.23  weight&#x3D;1;\n     server    192.168.10.24  weight&#x3D;2;\n&#125;\n3.iphash每个请求都根据访问ip的hash结果分配，经过这样的处理，每个访客固定访问一个后端服务，如下配置（ip_hash可以和weight配合使用）。\nupstream  dalaoyang-server &#123;\n       ip_hash; \n       server    192.168.10.23 weight&#x3D;1;\n       server    192.168.10.24 weight&#x3D;2;\n&#125;\n4.最少连接将请求分配到连接数最少的服务上。\nupstream  dalaoyang-server &#123;\n       least_conn;\n       server    192.168.10.23 weight&#x3D;1;\n       server    192.168.10.24 weight&#x3D;2;\n&#125;\n5.fair按后端服务器的响应时间来分配请求，响应时间短的优先分配。\nupstream  dalaoyang-server &#123;\n       server    192.168.10.23 weight&#x3D;1;\n       server    192.168.10.24 weight&#x3D;2;\n       fair;\n&#125;","slug":"Nginx负载均衡","date":"2020-06-24T12:21:33.000Z","categories_index":"Nginx","tags_index":"Nginx,Linux,教程","author_index":"Johnny"},{"id":"01b2f95cf7b3ad8e6df19f8a3034e6c8","title":"Nginx快速入门","content":"\n\n\n\n\n\n\n\n\n\nNginx(“engine x”)是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。在高连接并发的情况下，Nginx是Apache服务器不错的替代品。##安装Nginx这里我用CentOS为例：1.安装先决条件\n$ yum install yum-utils\n2.设置yum存储库，将下面内容写入/etc/yum.repos.d/nginx.repo\n$ vim &#x2F;etc&#x2F;yum.repos.d&#x2F;nginx.repo\n[nginx-stable]\nname&#x3D;nginx stable repo\nbaseurl&#x3D;http:&#x2F;&#x2F;nginx.org&#x2F;packages&#x2F;centos&#x2F;$releasever&#x2F;$basearch&#x2F;\ngpgcheck&#x3D;1\nenabled&#x3D;1\ngpgkey&#x3D;https:&#x2F;&#x2F;nginx.org&#x2F;keys&#x2F;nginx_signing.key\nmodule_hotfixes&#x3D;true\n3.安装Nginx\n$ yum update\n$ yum install nginx\n4.验证是否安装成功启动Nginx\n$ nginx\n查看端口80已被nginx监听\n$ netstat -ntlp\nActive Internet connections (only servers)\nProto Recv-Q Send-Q Local Address           Foreign Address         State       PID&#x2F;Program name    \ntcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      666&#x2F;sshd            \ntcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      799&#x2F;master          \ntcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      23779&#x2F;nginx: master \ntcp6       0      0 :::22                   :::*                    LISTEN      666&#x2F;sshd            \ntcp6       0      0 ::1:25                  :::*                    LISTEN      799&#x2F;master\n5.设置防火墙如果在浏览器里输入ip地址发现无法访问此网站，那有可能是防火墙80端口没有开放。\n编辑iptables配置文件\n$ vim &#x2F;etc&#x2F;sysconfig&#x2F;iptables\n添加开放80端口\n -A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEP\n重启iptables\n$ systemctl restart iptables\n们刷新页面出现Welcome to nginx!说明安装配置成功![welcone nginx.png](/images/Nginx快速入门/welcome to nginx.png)##Nginx常用命令\n$ nginx           — 启动Nginx\n$ nginx -t        — 检查Nginx配置文件\n$ nginx -s stop   — 快速关闭\n$ nginx -s quit   — 正常关闭\n$ nginx -s reload — 重新加载配置文件\n$ nginx -s reopen — 重新打开日志文件\n##Nginx主模块基本命令daemon语法: daemon on | off缺省值:on是否以守护进程的方式运行nginx，守护进程是指脱离终端并且在后台运行的进程，关闭守护进程可以方便我们调试nginx。\ndaemon off;\nmaster_process语法:master_process on | off缺省值:on是否以master/worker方式逬行工作，在实际的环境中nginx是以一个master逬程管理多个worker进程的方式运行的，关闭后nginx就不会fork出worker子进程来处理请求，而是用master进程自身来处理请求worker_processes number;默认1,在master/worker运行方式下worker进程的数目，一般情况下用户要配置与CPU内核数相等的worker进程。\nmaster_process off;\n\n\n\n\n\n\n\n\n\n\n生产环境中不要使用”daemon”和”master_process”指令，这些选项仅用于开发调试。\nerror_log语法:error_log file [ debug | info | notice | warn | error | crit ]缺省值:$&#123;prefix&#125;/logs/error.logNginx 添加 –with-debug 编译参数, 你还能够使用以下配置:\nerror_log LOGFILE [ debug_core | debug_alloc | debug_mutex | debug_event\n]: | debug_http | debug_imap ;\ninclude语法:include file | *缺省值:none你可以在任意地方使用include指令实现配置文件的包含，类似于apache中的include方法，可减少主配置文件。\n```指令还支持像下面配置一样的全局包含的方法，例如包含一个目录下所有以\".conf\"结尾的文件:&#96;&#96;&#96;\ninclude vhosts&#x2F;*.conf;\npid语法:pid file缺省值:compile-time option Example:进程id存储文件。可以使用 kill -HUP cat /var/log/nginx.pid\\ 对Nginx进行配置文件重新加载。\npid &#x2F;var&#x2F;log&#x2F;nginx.pid;\nuser语法:user user [group]缺省值:nobody nobody指定Nginx Worker进程运行用户，默认是nobody帐号。\n例如:\nuser www users;\nworker_processes语法:worker_processes number缺省值:1nginx可以使用多个worker进程，原因如下：\n1.使用SMP2.当工作程序在磁盘I / O上阻塞时减少延迟3.当使用select（）/ poll（）时限制每个进程的连接数\nworker_processes 4;\n##Nginx处理HTTP的核心功能模块\n基本指令alias语法:alias file-path|directory-path;缺省值:no使用字段:location该伪指令分配用于指定位置的路径。 请注意，它看起来类似于root伪指令，但是文档root不会改变，只是用于请求的文件系统路径。\nlocation  &#x2F;i&#x2F; &#123;\n alias   &#x2F;spool&#x2F;w3&#x2F;images&#x2F;;\n&#125;\n# 请求“ &#x2F;i&#x2F;1.jpg”将返回文件“ &#x2F;spool&#x2F;w3&#x2F;images&#x2F;1.jpg\nkeepalive_timeout语法: keepalive_timeout [ time ]缺省值:keepalive_timeout 75使用字段:http, server, location第一个参数为与客户端的保持活动连接分配超时。 在此时间之后，服务器将关闭连接。\n可选的第二个参数指定了答应头Keep-Alive: timeout=time的```time````值，这个值可以使一些浏览器知道什么时候关闭连接，以便使服务器不用重复关闭，如果不指定这个参数，nginx不会在答应头中发送Keep-Alive信息。\n下面列出了一些服务器如何处理包含Keep-Alive的答应头：\n\nMSIE和Opera会忽略“ Keep-Alive：timeout = ”标头。\nMSIE使连接保持活动状态约60-65秒，然后发送TCP RST。\nOpera可以长时间保持连接状态。\nMozilla使连接保持活动状态N大约1-10秒。\nKonqueror使连接保持活动状态约N秒钟。\n\nlisten语法:listen address:port [ default [ backlog=num | rcvbuf=size | sndbuf=size | accept_filter=filter | deferred | bind | ssl ] ]缺省值:listen 80使用字段:serverlisten指令指定封闭服务器{…}块接受的地址和端口。 可以仅指定地址，仅端口或服务器名称作为地址。\nlisten 127.0.0.1:8000;\nlisten 127.0.0.1;\nlisten 8000;\nlisten *:8000;\nlisten localhost:8000;\nIPv6地址（0.7.36）设置：\nlisten [::]:8000; \nlisten [fe80::1];\nlocation语法:location [=|~|~*|^~] /uri/ &#123; ... &#125;缺省值:no使用字段:server这个参数根据URL的不同需求来进行配置，可以使用字符串与正则表达式匹配，如果要使用正则表达式，你必须指定下列前缀：\n\n~*不区分大小写\n～区分大小写location  &#x3D; &#x2F; &#123;\n  # 只匹配 &#x2F; 的查询\n  [ configuration A ] \n&#125;\nlocation  &#x2F; &#123;\n  # 匹配任何以 &#x2F; 开头的查询\n  # 但是正则表达式与一些较长的字符串将首先匹配\n  [ configuration B ] \n&#125;\nlocation ^~ &#x2F;images&#x2F; &#123;\n  # 匹配任何以&#x2F;images&#x2F;开始的查询并且停止搜索，不检查正则表达式\n  [ configuration C ] \n&#125;\nlocation ~* \\.(gif|jpg|jpeg)$ &#123;\n  # 匹配任何以gif,jpg,jpeg结尾的文件，但是所有&#x2F;images&#x2F;目录请求将在Configuration C 中处理\n  [ configuration D ] \n&#125;\n\nresolver_timeout语法:resolver_timeout time使用字段:http,server,location解析超时时间。如：\nresolver_timeout 5s;\nroot语法:root path缺省值:root html使用字段:http,server,location,location中if字段请求到达后的文件根目录\nlocation  &#x2F;i&#x2F;  &#123;\n  root  &#x2F;spool&#x2F;w3\n&#125;\n如果亲求/i/top.jpg文件，nginx将转到/spool/w3/i/top.jpg文件。你可以在参数中使用变量。注意：在亲求中root会添加这个location到它的后面，即/i/top.jpg并不会请求/spool/w3/i/top.jpg文件，如果要实现上述类似与apache alias的功能，可以使用alias指令。server语法:server&#123;...&#125;缺省值:no使用字段:httpserver字段包含虚拟主机的配置。没有明确的机制来分开基于域名（请求中的主机头）和基于IP的虚拟主机。可以通过listen指令来指定必须连接到这个server块的所有地址和端口，并且在server_name指令中可以指定所有的域名。server_name语法:server_name name [...]使用字段:server将HTTP请求的主机头与nginx配置文件中的server字段中指定的参数进行匹配，并且找出第一个匹配结果。\n\n完整的静态名称\n名称开头带有通配符的名称— * .example.com\n名称末尾带有通配符的名称www.example.*\n具有正则表达式的名称\n\n如果不匹配，将根据以下顺序使用配置文件中的[#server服务器{…}]块：\n\nlisten指令被标记为default的server字段\n第一个出现listen的server字段\n\n","slug":"Nginx快速入门","date":"2020-06-22T10:23:05.000Z","categories_index":"Nginx","tags_index":"Nginx,Linux","author_index":"Johnny"},{"id":"8e903f5d8f6275843e8b600d4505da68","title":"Docker的安装和部署","content":"\n在Ubuntu中安装Docker要安装Docker Engine，您需要以下Ubuntu版本之一的64位版本：\n\nUbuntu Eoan 19.10\nUbuntu Bionic 18.04（LTS）\nUbuntu Xenial 16.04（LTS）\n其他最新版本\n\n安装前的检查\n检查内核版本Docker需要3.10+内核的linux操作系统。$ uname -a\nLinux ubuntu 5.4.0-26-generic #30-Ubuntu SMP Mon Apr 20 16:58:30 UTC 2020 x86_64 x86_64 x86_64 GNU&#x2F;Linux\n检查Device Mapper$ ls -l &#x2F;sys&#x2F;class&#x2F;misc&#x2F;device-mapper\nlrwxrwxrwx 1 root root 0 May 24 08:45 &#x2F;sys&#x2F;class&#x2F;misc&#x2F;device-mapper -&gt; ..&#x2F;..&#x2F;devices&#x2F;virtual&#x2F;misc&#x2F;device-mapper\n卸载旧的版本\n较旧的Docker版本名称为docker，docker.io或docker-engine。 如果已安装，请卸载它们：$ sudo apt-get remove docker docker-engine docker.io containerd runc\n如果提示以下结果,说明系统中没有安装较久版本的Docker。Reading package lists... Done\nBuilding dependency tree       \nReading state information... Done\nE: Unable to locate package docker-engine\n设置存储库\n更新apt软件包索引并安装软件包以允许apt通过HTTPS使用存储库：\n\n$ sudo apt-get update\n\n$ sudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    gnupg-agent \\\n    software-properties-common\n\n添加Docker的官方GPG密钥：\n\n$ curl -fsSL https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -\nOK\n通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥 。\nsudo apt-key fingerprint 0EBFCD88\npub   rsa4096 2017-02-22 [SCEA]\n         9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\nuid    [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;\nsub   rsa4096 2017-02-22 [S]\n\n使用以下命令来设置稳定的存储库。$ sudo add-apt-repository \\\n   &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu \\\n   $(lsb_release -cs) \\\n   stable&quot;\n安装Docker\n更新apt包索引，并安装最新版本的Docker Engine和容器。$ sudo apt-get update\n$ sudo apt-get install docker-ce docker-ce-cli containerd.io\n通过运行hello-world 映像来验证是否正确安装了Docker Engine 。$ sudo docker run hello-world\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n终端出现Hello from Docker!提示，说明Docker已经成功的安装到您的系统中。\n\n配置阿里云镜像加速\n登陆阿里云后再产品中找到容器镜像服务。\n\n进入控制台后点击镜像工具-镜像加速器。\n\n根据操作文档配置镜像加速。\n$ sudo mkdir -p &#x2F;etc&#x2F;docker\n$ sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;\n&#123;\n  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;&lt;加速器地址&gt;&quot;]\n&#125;\nEOF\n$ sudo systemctl daemon-reload\n$ sudo systemctl restart docker\n\n","slug":"Docker的安装和部署","date":"2020-05-26T09:33:20.000Z","categories_index":"Docker","tags_index":"Docker","author_index":"Johnny"},{"id":"ae3533aad9ffb390f0136b0f330276f7","title":"Docker相关技术简介","content":"\n\n\n\n\n\n\n\n\n\nDocker 是一个开源的应用容器引擎，基于Go 语言并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。\nDocker简介什么是容器？容器是一种虚拟化解决方案，相对于传统虚拟机不同。传统的虚拟机是用中间层，将一台或多台独立的机器虚拟运行在硬件之上。而容器则是直接运行操作系统之上的用户空间，因此容器虚拟又被称为操作系统虚拟化。由于容器依赖于操作系统的特性，因此容器只能运行相同或相似内核的操作系统。\nDocker使用的技术依赖于Linux内核的Namespace和Cgroups (Control Group) 等特性，所以Docker容器只能运行Linux类系统而不能运行Windows系统。这也是容器技术相对虚拟机技术系统灵活性上的劣势。\n\nDocker与虚拟机对比\n启动速度启动虚拟机需要先启动虚拟机的操作系统，再启动应用，这个过程非常慢。启动Docker相当于启动宿主机操作系统上的一个进程，为秒级别。\n\n资源占用更小从图中我们可以看到，使用虚拟机部署应用不但包含了应用和其所依赖的库，还包含了完整的操作系统;占用大量的磁盘空间、内存和CPU资源。Docker只需要应用和其依赖的库，在运行时占用很少的资源。\n\n镜像与容器镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改。\n\n\nDocker的特点\n提供简单轻量的建模方式用户只需要几分钟就可以将自己的程序Docker化。大多是Docker容器只需要不到一秒就可以启动。由于去除了管理程序的开销，Docker容器拥有更高的性能，同时一台宿主机中也可以运行更多的容器。使用户可以尽可能的利用系统资源。\n\n职责的逻辑分离使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心管理容器。\n\n快速高效的发开周期缩短代码从开发到测试到部署上线运行的周期，让应用具备可移植性。在容器中开发也就避免额外的调试、和部署上的开销，这样就有效的缩短了产品上线的周期。\n\n鼓励使用面向服务的架构Docker推荐单个容易只运行一个容器，这样就形成一个分布式的应用程序模型。在这样的模型下，应用程序和服务可以表现为一系列内部互联的容器，从而使分布式应用程序扩展或调试应用程序都变得非常简单。\n\n\nDocker的使用场景\n使用Docker容器开发、测试、部署服务\n创建隔离的运行环境\n搭建测试环境\n构建多用户的平台服务(PaaS)基础设施\n提供软件即服务(SaaS)应用程序\n高性能、超大规模的宿主机部署\n\nDocker优缺点\n\n\n\n\n\n\n\n\n参考链接:https://cloud.tencent.com/developer/article/1457282\n\n部署方便\n\n搭建环境这一步往往会耗费我们好几个小时的时间，而且其中一个小问题可能需要找很久才能够解决。你还会得到关于环境搭建方面的团队其他成员的求助。而有了容器之后，这些都变得非常容易，你的开发环境就只是一个或者几个容器镜像的地址，最多再需要一个控制部署流程的执行脚本。2. 部署安全\n当我们收到一个bug反馈的时候，很多时候心里面的第一反应一定是“我本地是好的啊”！ 这种情况的发生就在于环境的不一致，我们在开发过程中的调试往往不能保证其他环境的问题，但是我们却要为此买单，这真是一件令人苦恼的事情。有了容器之后，这将很少发生。我们可以通过容器技术将开发环境和测试环境以及生产环境保持版本和依赖上的统一，保证代码在一个高度统一的环境上执行。而测试环境的统一，也同样能解决CI流程对环境的要求。\n分布式技术和扩容需求日益增长的今天，如果运维能够使用容器技术来进行环境的部署，不仅仅在部署时间上节省不少，也能把很多因为人工配置环境产生的失误降到最低。\n\n隔离性好\n\n不管是开发还是生产，往往我们一台机器上可能需要跑多个服务，而服务各自需要的依赖配置不尽相同，假如说两个应用需要使用同一个依赖，或者两个应用需要的依赖之间会有一些冲突，这个时候就很容易出现问题了。 所以同一台服务器上不同应用提供的不同服务，最好还是将其隔离起来。而容器在这方面有天生的优势，每一个容器就是一个隔离的环境，你对容器内部提供服务的要求，容器可以自依赖的全部提供。这种高内聚的表现可以实现快速的分离有问题的服务，在一些复杂系统中能实现快速排错和及时处理。(当然需要说明的是，这个隔离性只是相对于服务器比较的，虚机技术要拥有更好的隔离性)\n\n快速回滚\n\n容器之前的回滚机制，一般需要基于上个版本的应用重新部署，且替换掉目前的问题版本。在最初的时代，可能是一套完整的开发到部署的流程，而执行这一套流程往往需要很长的时间。在基于git的环境中，可能是回退某个历史提交，然后重新部署。这些跟容器技术相比都不够快，而且可能会引起新的问题（因为是基于新版本的修改）。而容器技术天生带有回滚属性，因为每个历史容器或者镜像都会有保存，而替换一个容器或者某个历史镜像是非常快速和简单的。\n\n成本低\n\n这可能是一个最明显和有用的优点了，在容器出现之前，我们往往构筑一个应用就需要一台新的服务器或者一台虚机。服务器的购置成本和运维成本都很高，而虚机需要占用很多不必要的资源。相比之下，容器技术就小巧轻便的多，只需要给一个容器内部构建应用需要的依赖就可以了，这也是容器技术发展迅速的最主要原因。\n\n管理成本更低\n\n随着容器技术的不断普及和发展，随之而来的容器管理和编排技术也同样得到发展。诸如Docker Swarm，Kubernetes, Mesos等编排工具也在不断的迭代更新，这让容器技术在生产环境中拥有了更多的可能性和更大的发挥空间。而随着大环境的发展，docker等容器的使用和学习的成本也是愈发降低，成为更多开发者和企业的选择。\n说了这么多的优点，容器也有一些问题是没有解决的。上一代方案基本就是基于虚机技术的云方案，能有效增加服务器的使用效率，达到节省成本的目的，而容器技术在此基础上更进一步地优化了资源的使用率。但是仍然有一些问题，是我们在选择服务资源架构场景中需要考虑的：\n\n 隔离性\n\n基于hypervisor的虚机技术，在隔离性上比容器技术要更好，它们的系统硬件资源完全是虚拟化的，当一台虚机出现系统级别的问题，往往不会蔓延到同一宿主机上的其他虚机。但是容器就不一样了，容器之间共享同一个操作系统内核以及其他组件，所以在收到攻击之类的情况发生时，更容易通过底层操作系统影响到其他容器。当然，这个问题可以通过在虚机中部署容器来解决，可是这样又会引出新的问题，比如成本的增加以及下面要提到的问题：性能。\n\n性能\n\n不管是虚机还是容器，都是运用不同的技术，对应用本身进行了一定程度的封装和隔离，在降低应用和应用之间以及应用和环境之间的耦合性上做了很多努力，但是随机而来的，就会产生更多的网络连接转发以及数据交互，这在低并发系统上表现不会太明显，而且往往不会成为一个应用的瓶颈（可能会分散于不同的虚机或者服务器上），但是当同一虚机或者服务器下面的容器需要更高并发量支撑的时候，也就是并发问题成为应用瓶颈的时候，容器会将这个问题放大，所以，并不是所有的应用场景都是适用于容器技术的。\n\n存储方案\n\n容器的诞生并不是为OS抽象服务的，这是它和虚机最大的区别，这样的基因意味着容器天生是为应用环境做更多的努力，容器的伸缩也是基于容器的这一disposable特性，而与之相对的，需要持久化存储方案恰恰相反。这一点docker容器提供的解决方案是利用volume接口形成数据的映射和转移，以实现数据持久化的目的。但是这样同样也会造成一部分资源的浪费和更多交互的发生，不管是映射到宿主机上还是到网络磁盘，都是退而求其次的解决方案。\n随着硬件技术和网络技术的迭代发展，容器技术的缺点会变得越来越不那么明显，而且随着容器技术的发展和普及，对应的解决方案也会越来越多。所以总体来看，docker等容器技术会朝着更加普及的趋势走近我们技术领域。 也希望每一位热爱技术的小伙伴们能更加了解这些新技术，让它们能够更好的为我们服务。\n","slug":"Docker相关技术简介","date":"2020-05-12T14:14:20.000Z","categories_index":"Docker","tags_index":"Docker","author_index":"Johnny"},{"id":"70dd287eea3c3b1a2c451ddd5cf0b7eb","title":"Frp内网穿透","content":"Frp内网穿透Frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp 协议，为 http 和 https 应用协议提供了额外的能力，且尝试性支持了点对点穿透。项目地址：https://github.com/fatedier/frp\n安装FrpFRP 采用 Go 语言开发，支持 Windows、Linux、MacOS、ARM等多平台部署。这里我用的是Centos 8，为了方便管理我们把解压后的目录重命名为 frp\nwget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.33.0&#x2F;frp_0.33.0_linux_amd64.tar.gz\ntar xzvf frp_0.33.0_linux_amd64.tar.gz\nmv frp_0.33.0_linux_amd64 frp\n\nFRP 服务端配置配置 FRP 服务端的前提条件是需要一台具有公网 IP的设备。\nFRP 默认给出两个服务端配置文件，一个是简版的 frps.ini，另一个是完整版本 frps_full.ini。通过frps.ini这个配置可以快速的搭建起一个 FRP 服务端。\n$ cat frps.ini\n\n[common]\nbind_port &#x3D; 7000 \n默认配置中监听的是 7000 端口，可根据自己实际情况修改。\n\n启动 FRP 服务端\n$ .&#x2F;frps -c .&#x2F;frps.ini\n2020&#x2F;05&#x2F;08 01:02:31 [I] [service.go:178] frps tcp listen on 0.0.0.0:7000\n2020&#x2F;05&#x2F;08 01:02:31 [I] [root.go:209] start frps success\n\nFRP 客户端配置编辑 frpc.ini\n$ vim frpc.ini\n\n[common]\n#server_addr 为 FRP 服务端的公网 IP\nserver_addr &#x3D; 192.168.50.11\n#server_port 为 FRP 服务端监听的端口\nserver_port &#x3D; 7000\n# Linu SSH服务\n[ssh]\n#网络协议\ntype &#x3D; tcp\n#填写客户端主机IP\nlocal_ip &#x3D; 192.168.50.12\n#Linux远程端口\nlocal_port &#x3D; 22\n#代理到服务端的端口这里我用6000\nremote_port &#x3D; 6000\n# Windows远程服务器\n[rdp]\n#网络协议\ntype &#x3D; tcp\n#填写客户端主机IP\nlocal_ip &#x3D; 192.168.50.13\n#Windows远程端口，默认是3389\nlocal_port &#x3D; 3389\n#代理到服务端的端口这里我用23389\nremote_port &#x3D; 23389\n启动 FRP 客户端\n$ .&#x2F;frpc -c .&#x2F;frpc.ini\n2020&#x2F;05&#x2F;07 23:18:53 [I] [service.go:282] [adbfac88ab64d72f] login to server success, get run id [adbfac88ab64d72f], server udp port [0]\n2020&#x2F;05&#x2F;07 23:18:53 [I] [proxy_manager.go:144] [adbfac88ab64d72f] proxy added: [ssh]\n2020&#x2F;05&#x2F;07 23:18:53 [I] [control.go:179] [adbfac88ab64d72f] [ssh] start proxy success\n我们查看服务端的提示\n2020&#x2F;05&#x2F;08 07:18:49 [I] [service.go:178] frps tcp listen on 0.0.0.0:7000\n2020&#x2F;05&#x2F;08 07:18:49 [I] [root.go:209] start frps success\n2020&#x2F;05&#x2F;08 07:18:55 [I] [service.go:432] [adbfac88ab64d72f] client login info: ip [192.168.50.12:39836] version [0.33.0] hostname [] os [linux] arch [amd64]\n2020&#x2F;05&#x2F;08 07:18:55 [I] [tcp.go:63] [adbfac88ab64d72f] [ssh] tcp proxy listen port [6000]\n2020&#x2F;05&#x2F;08 07:18:55 [I] [control.go:445] [adbfac88ab64d72f] new proxy [ssh] success\n可以看到我们的SSH服务已经成功连接到服务端的6000端口。\n$ ssh root@192.168.50.11 -p 6000\nThe authenticity of host &#39;[192.168.50.11]:6000 ([192.168.50.11]:6000)&#39; can&#39;t be established.\nECDSA key fingerprint is SHA256:jwBjW8YC0VaFaTRTJaB8EJDuAZFZ6MBlh6pJbSVjngU.\nAre you sure you want to continue connecting (yes&#x2F;no)?\n可以看到已经可以成功连接到服务器。\n将服务添加至systemctl这里以frp服务端为例\n将frp/systemd目录下的frps.service复制到/etc/systemd/system/目录下\n$ cp &#x2F;frp&#x2F;systemd&#x2F;frps.service &#x2F;etc&#x2F;systemd&#x2F;system\n复制配置文件和二进制文件到相对应的目录\n$ cp &#x2F;frps &#x2F;usr&#x2F;bin\n$ cp &#x2F;frps.ini &#x2F;etc&#x2F;frp\n重新加载服务配置\n$ systemctl daemon-reload\n设置为开机启动\n$ systemctl enable frps.service\n到这里就完成了Frp服务的所有配置，这样就能随时随地的访问我们家中的电脑了。\n","slug":"Frp内网穿透","date":"2020-05-08T07:02:40.000Z","categories_index":"教程","tags_index":"-Linux -教程","author_index":"Johnny"},{"id":"d5477574fa77bf54e6e43f047273c678","title":"Samba快速入门","content":"安装Samba[root@localhost ~]# yum install samba -y\n[root@localhost ~]# cd &#x2F;etc&#x2F;samba&#x2F;\n[root@localhost samba]# ls\nlmhosts  smb.conf  smb.conf.example\n[root@localhost samba]# mv smb.conf smb.conf.bak\n[root@localhost samba]# grep -v &quot;#&quot; smb.conf.bak &gt; smb.conf \n\n配置文件smb.conf[root@localhost samba]# vim smb.conf\n\n[global]\n        workgroup &#x3D; SAMBA\n        security &#x3D; user \n\n        passdb backend &#x3D; tdbsam\n\n        printing &#x3D; cups\n        printcap name &#x3D; cups\n        load printers &#x3D; yes\n        cups options &#x3D; raw\n[myshare]\n                ##共享文件目录路径\n                path&#x3D;&#x2F;opt&#x2F;wbm         \n                browseable&#x3D;yes\n                create mask&#x3D;0644\n                directory mask&#x3D;0755\n                ##允许访问的用户\n                valid users&#x3D;wbm\n                ##允许写入的用户\n                write list&#x3D;wbm  \n创建用户[root@localhost samba]#useradd wbm\n给用户设置密码[root@localhost samba]#smbpasswd -a wbm \n列出smb用户列表[root@localhost samba]#pdbedit -L  \nwbm:1000:\n创建Samba共享目录[root@localhost ~]#mkdir &#x2F;opt&#x2F;wbm\n[root@localhost ~]#chmod 777 &#x2F;opt&#x2F;wbm\n[root@localhost ~]#systemctl start smb.service \n挂在samba共享[root@vm22 ~]# mount -t cifs &#x2F;&#x2F;192.168.10.21&#x2F;wbm &#x2F;opt&#x2F;wbm&#x2F; -o username&#x3D;wbm,password&#x3D;qwer1.2.3.\n[root@vm22 ~]# cd &#x2F;opt&#x2F;wbm&#x2F;\n[root@vm22 wbm]# ls\nInstall_nginx.sh\n开机自动挂载[root@vm22 wbm]# vim &#x2F;etc&#x2F;fstab\n\n#在末尾处添加\n\n&#x2F;&#x2F;192.168.10.21 &#x2F;opt&#x2F;wbm    cifs username&#x3D;wbm,password&#x3D;qwer1.2.3. 0 0","slug":"Samba快速入门","date":"2019-06-27T09:35:23.000Z","categories_index":"教程","tags_index":"Linux,教程","author_index":"Johnny"},{"id":"065300218eb4a63be27d42f44bfa37db","title":"搭建LAMP环境","content":"1搭建 MySQL 数据库安装 MySQL使用 yum 安装 MySQL：\nyum install mysql-server -y\n安装完成后，启动 MySQL 服务：\nservice mysqld restart\n设置 MySQL 账户 root 密码：[?]\n&#x2F;usr&#x2F;bin&#x2F;mysqladmin -u root password &#39;Password&#39;\n\n2安装 Apache 服务安装 Apache使用 yum 安装 Apache\nyum install httpd -y\n启动 Apache 服务：\nservice httpd start\n3安装 PHP安装 PHP 和 PHP-MYSQL 支持工具：使用 yum 安装 PHP：[?]\nyum install php php-mysql -y\nCentOS 6 默认已经安装了 php-mysql，下面命令执行的可能会提示已经安装。\n4检查安装是否成功检验 PHP 是否安装成功我们在 /var/www/html 目录下创建一个info.php文件来检查php是否安装成功，示例代码参考如下\n示例代码：/var/www/html/info.php\n&lt;?php phpinfo(); ?&gt;\n重启 Apache 服务：\nservice httpd restart\n此时，访问 http://&lt;您的 CVM IP 地址&gt;/info.php 可浏览到我们刚刚创建的 info.php 页面了\n","slug":"搭建LAMP环境","date":"2019-06-14T10:11:41.000Z","categories_index":"教程","tags_index":"Linux,教程","author_index":"Johnny"}]