{"title":"Docker-Compose","uid":"0361f9a39ac53c480f13924da3215802","slug":"Docker-Compose","date":"2022-10-16T02:38:51.000Z","updated":"2022-10-26T03:03:07.624Z","comments":true,"path":"api/articles/Docker-Compose.json","keywords":null,"cover":"/images/docker-compose.jpg","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p>\n<p>其代码目前在 <a href=\"https://github.com/docker/compose\">https://github.com/docker/compose</a> 上开源。</p>\n<p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p>\n<p>通过第一部分中的介绍，我们知道使用一个 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>\n<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>\n<p><code>Compose</code> 中有两个重要的概念：</p>\n<ul>\n<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>\n<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>\n</ul>\n<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>\n<p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>\n<h3 id=\"安装与卸载\"><a href=\"#安装与卸载\" class=\"headerlink\" title=\"安装与卸载\"></a>安装与卸载</h3><h6 id=\"1-linux\"><a href=\"#1-linux\" class=\"headerlink\" title=\"1.linux\"></a>1.linux</h6><ul>\n<li>在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ curl -SL https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;v2.12.2&#x2F;docker-compose-linux-x86_64 -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose\n$ sudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose &#x2F;usr&#x2F;bin&#x2F;docker-compose</code></pre>\n\n<h6 id=\"2-macos、window\"><a href=\"#2-macos、window\" class=\"headerlink\" title=\"2.macos、window\"></a>2.macos、window</h6><ul>\n<li>Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。<code>Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用</code>。</li>\n</ul>\n<h6 id=\"3-测试安装成功\"><a href=\"#3-测试安装成功\" class=\"headerlink\" title=\"3.测试安装成功\"></a>3.测试安装成功</h6><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker-compose -v\nDocker Compose version v2.11.2</code></pre>\n\n<h6 id=\"4-卸载\"><a href=\"#4-卸载\" class=\"headerlink\" title=\"4.卸载\"></a>4.卸载</h6><ul>\n<li>如果是二进制包方式安装的，删除二进制文件即可。</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ sudo rm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</code></pre>\n\n<h3 id=\"docker-compose使用\"><a href=\"#docker-compose使用\" class=\"headerlink\" title=\"docker compose使用\"></a>docker compose使用</h3><pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\"># 1.相关概念</code></pre>\n\n<p>首先介绍几个术语。</p>\n<ul>\n<li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li>\n<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。∂一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</li>\n</ul>\n<pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\"># 2.场景</code></pre>\n\n<p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>\n<ul>\n<li>springboot应用</li>\n<li>mysql服务</li>\n<li>redis服务</li>\n<li>elasticsearch服务</li>\n<li>…….</li>\n</ul>\n<pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\"># 3.docker-compose模板\n- 参考文档:https:&#x2F;&#x2F;docker_practice.gitee.io&#x2F;zh-cn&#x2F;compose&#x2F;compose_file.html</code></pre>\n\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">version: &quot;3.0&quot;\nservices:\n  mysqldb:\n    image: mysql:5.7.19\n    container_name: mysql\n    ports:\n      - &quot;3306:3306&quot;\n    volumes:\n      - &#x2F;root&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d\n      - &#x2F;root&#x2F;mysql&#x2F;logs:&#x2F;logs\n      - &#x2F;root&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: root\n    networks:\n      - ems\n    depends_on:\n      - redis\n\n  redis:\n    image: redis:4.0.14\n    container_name: redis\n    ports:\n      - &quot;6379:6379&quot;\n    networks:\n      - ems\n    volumes:\n      - &#x2F;root&#x2F;redis&#x2F;data:&#x2F;data\n    command: redis-server\n    \nnetworks:\n  ems:</code></pre>\n\n<pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\"># 4.通过docker-compose运行一组容器\n- 参考文档:https:&#x2F;&#x2F;docker_practice.gitee.io&#x2F;zh-cn&#x2F;compose&#x2F;commands.html</code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@centos ~]# docker-compose up    \t\t\t\t\t\t\t&#x2F;&#x2F;前台启动一组服务\n[root@centos ~]# docker-compose up -d \t\t\t\t\t\t\t&#x2F;&#x2F;后台启动一组服务</code></pre>\n\n<hr>\n<h3 id=\"docker-compose-模板文件\"><a href=\"#docker-compose-模板文件\" class=\"headerlink\" title=\"docker-compose 模板文件\"></a>docker-compose 模板文件</h3><p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p>\n<p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">version: &quot;3&quot;\n\nservices:\n  webapp:\n    image: examples&#x2F;web\n    ports:\n      - &quot;80:80&quot;\n    volumes:\n      - &quot;&#x2F;data&quot;</code></pre>\n\n<p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p>\n<p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p>\n<p>下面分别介绍各个指令的用法。</p>\n<h4 id=\"build\"><a href=\"#build\" class=\"headerlink\" title=\"build\"></a><code>build</code></h4><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">version: &#39;3&#39;\nservices:\n\n  webapp:\n    build: .&#x2F;dir</code></pre>\n\n<p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p>\n<p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p>\n<p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">version: &#39;3&#39;\nservices:\n\n  webapp:\n    build:\n      context: .&#x2F;dir\n      dockerfile: Dockerfile-alternate\n      args:\n        buildno: 1</code></pre>\n\n<h4 id=\"command\"><a href=\"#command\" class=\"headerlink\" title=\"command\"></a><code>command</code></h4><p>覆盖容器启动后默认执行的命令。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">command: echo &quot;hello world&quot;</code></pre>\n\n<h4 id=\"container-name\"><a href=\"#container-name\" class=\"headerlink\" title=\"container_name\"></a><code>container_name</code></h4><p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">container_name: docker-web-container</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p></blockquote>\n<h4 id=\"depends-on\"><a href=\"#depends-on\" class=\"headerlink\" title=\"depends_on\"></a><code>depends_on</code></h4><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">version: &#39;3&#39;\n\nservices:\n  web:\n    build: .\n    depends_on:\n      - db\n      - redis\n\n  redis:\n    image: redis\n\n  db:\n    image: postgres</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p></blockquote>\n<h4 id=\"env-file\"><a href=\"#env-file\" class=\"headerlink\" title=\"env_file\"></a><code>env_file</code></h4><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>\n<p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p>\n<p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">env_file: .env\n\nenv_file:\n  - .&#x2F;common.env\n  - .&#x2F;apps&#x2F;web.env\n  - &#x2F;opt&#x2F;secrets.env</code></pre>\n\n<p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># common.env: Set development environment\nPROG_ENV&#x3D;development</code></pre>\n\n<h4 id=\"environment\"><a href=\"#environment\" class=\"headerlink\" title=\"environment\"></a><code>environment</code></h4><p>设置环境变量。你可以使用数组或字典两种格式。</p>\n<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">environment:\n  RACK_ENV: development\n  SESSION_SECRET:\n\nenvironment:\n  - RACK_ENV&#x3D;development\n  - SESSION_SECRET</code></pre>\n\n<p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a href=\"https://yaml.org/type/bool.html\">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF</code></pre>\n\n<h4 id=\"healthcheck\"><a href=\"#healthcheck\" class=\"headerlink\" title=\"healthcheck\"></a><code>healthcheck</code></h4><p>通过命令检查容器是否健康运行。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">healthcheck:\n  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http:&#x2F;&#x2F;localhost&quot;]\n  interval: 1m30s\n  timeout: 10s\n  retries: 3</code></pre>\n\n<h4 id=\"image\"><a href=\"#image\" class=\"headerlink\" title=\"image\"></a><code>image</code></h4><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">image: ubuntu\nimage: orchardup&#x2F;postgresql\nimage: a4bc65fd</code></pre>\n\n<h4 id=\"networks\"><a href=\"#networks\" class=\"headerlink\" title=\"networks\"></a><code>networks</code></h4><p>配置容器连接的网络。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">version: &quot;3&quot;\nservices:\n\n  some-service:\n    networks:\n     - some-network\n     - other-network\n\nnetworks:\n  some-network:\n  other-network:</code></pre>\n\n<h4 id=\"ports\"><a href=\"#ports\" class=\"headerlink\" title=\"ports\"></a><code>ports</code></h4><p>暴露端口信息。</p>\n<p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">ports:\n - &quot;3000&quot;\n - &quot;8000:8000&quot;\n - &quot;49100:22&quot;\n - &quot;127.0.0.1:8001:8001&quot;</code></pre>\n\n<p><em>注意：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <code>YAML</code> 会自动解析 <code>xx:yy</code> 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p>\n<h4 id=\"sysctls\"><a href=\"#sysctls\" class=\"headerlink\" title=\"sysctls\"></a><code>sysctls</code></h4><p>配置容器内核参数。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">sysctls:\n  net.core.somaxconn: 1024\n  net.ipv4.tcp_syncookies: 0\n\nsysctls:\n  - net.core.somaxconn&#x3D;1024\n  - net.ipv4.tcp_syncookies&#x3D;0</code></pre>\n\n<h4 id=\"ulimits\"><a href=\"#ulimits\" class=\"headerlink\" title=\"ulimits\"></a><code>ulimits</code></h4><p>指定容器的 ulimits 限制值。</p>\n<p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">ulimits:\n  nproc: 65535\n  nofile:\n    soft: 20000\n    hard: 40000</code></pre>\n\n<h4 id=\"volumes\"><a href=\"#volumes\" class=\"headerlink\" title=\"volumes\"></a><code>volumes</code></h4><p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p>\n<p>该指令中路径支持相对路径。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">volumes:\n - &#x2F;var&#x2F;lib&#x2F;mysql\n - cache&#x2F;:&#x2F;tmp&#x2F;cache\n - ~&#x2F;configs:&#x2F;etc&#x2F;configs&#x2F;:ro</code></pre>\n\n<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">version: &quot;3&quot;\n\nservices:\n  my_src:\n    image: mysql:8.0\n    volumes:\n      - mysql_data:&#x2F;var&#x2F;lib&#x2F;mysql\n\nvolumes:\n  mysql_data:</code></pre>\n\n<hr>\n<h3 id=\"docker-compose-常用命令\"><a href=\"#docker-compose-常用命令\" class=\"headerlink\" title=\"docker-compose 常用命令\"></a>docker-compose 常用命令</h3><h5 id=\"1-命令对象与格式\"><a href=\"#1-命令对象与格式\" class=\"headerlink\" title=\"1. 命令对象与格式\"></a>1. 命令对象与格式</h5><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>\n<p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p>\n<p><code>docker-compose</code> 命令的基本的使用格式是</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker-compose [-f&#x3D;&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</code></pre>\n\n<h5 id=\"2-命令选项\"><a href=\"#2-命令选项\" class=\"headerlink\" title=\"2. 命令选项\"></a>2. 命令选项</h5><ul>\n<li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li>\n<li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li>\n<li><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</li>\n<li><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 <code>bridge</code></li>\n<li><code>--verbose</code> 输出更多调试信息。</li>\n<li><code>-v, --version</code> 打印版本并退出。</li>\n</ul>\n<h5 id=\"3-命令使用说明\"><a href=\"#3-命令使用说明\" class=\"headerlink\" title=\"3.命令使用说明\"></a>3.命令使用说明</h5><h5 id=\"up\"><a href=\"#up\" class=\"headerlink\" title=\"up\"></a><code>up</code></h5><p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p>\n<ul>\n<li><p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>\n</li>\n<li><p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>\n</li>\n<li><p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>\n</li>\n<li><p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>\n</li>\n<li><p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p>\n</li>\n<li><p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>\n</li>\n<li><p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容</p>\n</li>\n</ul>\n<hr>\n<h5 id=\"down\"><a href=\"#down\" class=\"headerlink\" title=\"down\"></a><code>down</code></h5><ul>\n<li>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</li>\n</ul>\n<hr>\n<h5 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec\"></a><code>exec</code></h5><ul>\n<li>进入指定的容器。</li>\n</ul>\n<hr>\n<h5 id=\"ps\"><a href=\"#ps\" class=\"headerlink\" title=\"ps\"></a><code>ps</code></h5><p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p>\n<p>列出项目中目前的所有容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-q</code> 只打印容器的 ID 信息。</li>\n</ul>\n<hr>\n<h5 id=\"restart\"><a href=\"#restart\" class=\"headerlink\" title=\"restart\"></a><code>restart</code></h5><p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p>\n<p>重启项目中的服务。</p>\n<p>选项：</p>\n<ul>\n<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li>\n</ul>\n<hr>\n<h5 id=\"rm\"><a href=\"#rm\" class=\"headerlink\" title=\"rm\"></a><code>rm</code></h5><p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p>\n<p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>\n<li><code>-v</code> 删除容器所挂载的数据卷。</li>\n</ul>\n<hr>\n<h5 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start\"></a><code>start</code></h5><p>格式为 <code>docker-compose start [SERVICE...]</code>。</p>\n<p>启动已经存在的服务容器。</p>\n<hr>\n<h5 id=\"stop\"><a href=\"#stop\" class=\"headerlink\" title=\"stop\"></a><code>stop</code></h5><p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p>\n<p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p>\n<p>选项：</p>\n<ul>\n<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>\n</ul>\n<hr>\n<h5 id=\"top\"><a href=\"#top\" class=\"headerlink\" title=\"top\"></a><code>top</code></h5><p>查看各个服务容器内运行的进程。</p>\n<hr>\n<h5 id=\"unpause\"><a href=\"#unpause\" class=\"headerlink\" title=\"unpause\"></a><code>unpause</code></h5><p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p>\n<p>恢复处于暂停状态中的服务。</p>\n<hr>\n","feature":true,"text":"简介Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 OpenStack 中的 Heat 十分类似。 其代码目前在 https://github.com/docker/compose 上开源。 Compose 定位...","link":"","photos":[],"count_time":{"symbolsCount":"8.1k","symbolsTime":"7 mins."},"categories":[{"name":"docker","slug":"docker","count":1,"path":"api/categories/docker.json"}],"tags":[{"name":"docker","slug":"docker","count":1,"path":"api/tags/docker.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD\"><span class=\"toc-text\">安装与卸载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#1-linux\"><span class=\"toc-text\">1.linux</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2-macos%E3%80%81window\"><span class=\"toc-text\">2.macos、window</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#3-%E6%B5%8B%E8%AF%95%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F\"><span class=\"toc-text\">3.测试安装成功</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#4-%E5%8D%B8%E8%BD%BD\"><span class=\"toc-text\">4.卸载</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#docker-compose%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">docker compose使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#docker-compose-%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">docker-compose 模板文件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#build\"><span class=\"toc-text\">build</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#command\"><span class=\"toc-text\">command</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#container-name\"><span class=\"toc-text\">container_name</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#depends-on\"><span class=\"toc-text\">depends_on</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#env-file\"><span class=\"toc-text\">env_file</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#environment\"><span class=\"toc-text\">environment</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#healthcheck\"><span class=\"toc-text\">healthcheck</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#image\"><span class=\"toc-text\">image</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#networks\"><span class=\"toc-text\">networks</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ports\"><span class=\"toc-text\">ports</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#sysctls\"><span class=\"toc-text\">sysctls</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ulimits\"><span class=\"toc-text\">ulimits</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#volumes\"><span class=\"toc-text\">volumes</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#docker-compose-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">docker-compose 常用命令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%91%BD%E4%BB%A4%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">1. 命令对象与格式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9\"><span class=\"toc-text\">2. 命令选项</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">3.命令使用说明</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#up\"><span class=\"toc-text\">up</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#down\"><span class=\"toc-text\">down</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#exec\"><span class=\"toc-text\">exec</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#ps\"><span class=\"toc-text\">ps</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#restart\"><span class=\"toc-text\">restart</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#rm\"><span class=\"toc-text\">rm</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#start\"><span class=\"toc-text\">start</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#stop\"><span class=\"toc-text\">stop</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#top\"><span class=\"toc-text\">top</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#unpause\"><span class=\"toc-text\">unpause</span></a></li></ol></li></ol></li></ol>","author":{"name":"Johnny","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"Welcome to my blog <br/> I'm Johnny Bao.-a DevOps.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"Dockerfile","uid":"75603112ad785d198fb30f0b34b1d632","slug":"Dockerflie","date":"2022-10-01T06:21:20.000Z","updated":"2022-10-24T08:23:39.316Z","comments":true,"path":"api/articles/Dockerflie.json","keywords":null,"cover":"/images/Dockerflie/image-20221024134827132.png","text":"Dockerfile1. 什么是DockerfileDockerfile可以认为是Docker镜像的描述文件，是由一系列命令和参数构成的脚本。主要作用是用来构建docker镜像的构建文件。 通过架构图可以看出通过DockerFile可以直接构建镜像 2. Dockerfile解析...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"Docker","slug":"Docker","count":5,"path":"api/categories/Docker.json"}],"tags":[{"name":"Docker","slug":"Docker","count":5,"path":"api/tags/Docker.json"}],"author":{"name":"Johnny","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"Welcome to my blog <br/> I'm Johnny Bao.-a DevOps.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}